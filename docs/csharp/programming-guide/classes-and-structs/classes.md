---
title: Руководство по программированию на C#. Классы
description: Сведения о типах классов и их создании
ms.date: 08/21/2018
helpviewer_keywords:
- classes [C#]
- C# language, classes
ms.assetid: e8848524-7273-429f-8aba-c658d5eff5ad
ms.openlocfilehash: 8fa8d33ce9ece20a18c5c1542bc44cf569e9fa2e
ms.sourcegitcommit: 30a686fd4377fe6472aa04e215c0de711bc1c322
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/10/2020
ms.locfileid: "94440410"
---
# <a name="classes-c-programming-guide"></a>Классы (Руководство по программированию на C#)

## <a name="reference-types"></a>Ссылочные типы  

Тип, который определен как [класс](../../language-reference/keywords/class.md), является *ссылочным типом*. Когда во время выполнения вы объявляете переменную ссылочного типа, такая переменная будет содержать значение [NULL](../../language-reference/keywords/null.md), пока вы явным образом не создадите экземпляр класса с помощью оператора [new](../../language-reference/operators/new-operator.md) или не назначите его объекту совместимого типа, созданному в другом месте, как показано в следующем примере:

```csharp
//Declaring an object of type MyClass.
MyClass mc = new MyClass();

//Declaring another object of the same type, assigning it the value of the first object.
MyClass mc2 = mc;
```

При создании объекта выделяется достаточный объем памяти для этого объекта в управляемой куче, и переменная хранит только ссылку на расположение данного объекта. Хранение типов в управляемой куче требует дополнительных действий как при выделении памяти, так и при удалении, которое выполняется функцией автоматического управления памятью в среде CLR, известной как *сборка мусора*. Сборка мусора является хорошо оптимизированным процессом и в большинстве случаев не создает помех для производительности. Дополнительные сведения о сборке мусора см. в разделе [Автоматическое управление памятью и сборка мусора](../../../standard/garbage-collection/fundamentals.md).  
  
## <a name="declaring-classes"></a>Объявление классов

 Классы объявляются с помощью ключевого слова [class](../../language-reference/keywords/class.md), за которым следует уникальный идентификатор, как показано в следующем примере:

 ```csharp
//[access modifier] - [class] - [identifier]
 public class Customer
 {
    // Fields, properties, methods and events go here...
 }
```

 Ключевому слову `class` предшествует уровень доступа. Так как в этом случае используется открытый класс ([public](../../language-reference/keywords/public.md)), любой пользователь может создавать его экземпляры. За ключевым словом `class` следует имя класса. Имя класса должно быть допустимым [именем идентификатора](../inside-a-program/identifier-names.md) C#. Оставшаяся часть определения — это тело класса, в котором задаются данные и поведение. Поля, свойства, методы и события в классе собирательно называются *членами класса*.  
  
## <a name="creating-objects"></a>Создание объектов

Несмотря на то, что они иногда взаимозаменяемы, класс и объект — разные вещи. Класс определяет тип объекта, но не является объектом. Объект — это конкретная сущность, основанная на классе, которую иногда называют экземпляром класса.  
  
 Объекты можно создавать с помощью ключевого слова [new](../../language-reference/operators/new-operator.md), за которым следует имя класса, на котором будет основан объект, например следующим образом:  

 ```csharp
 Customer object1 = new Customer();
 ```

 При создании экземпляра класса ссылка на объект передается программисту. В предыдущем примере `object1` представляет собой ссылку на объект, который основан на `Customer`. Эта ссылка указывает на новый объект, но не содержит данные этого объекта. Фактически, можно создать ссылку на объект без создания собственно объекта:  

```csharp
 Customer object2;
```

 Создание таких ссылок, которые не указывают на объект, не рекомендуется, так как попытка доступа к объекту по такой ссылке приведет к сбою во время выполнения. Однако такую ссылку можно сделать указывающей на объект, создав новый объект или назначив ее существующему объекту, как показано далее:  

 ```csharp
 Customer object3 = new Customer();
 Customer object4 = object3;
```
  
 В этом коде создаются две ссылки на объект, которые указывают на один и тот же объект. Таким образом, любые изменения объекта, выполненные посредством `object3`, отражаются при последующем использовании `object4`. Поскольку на объекты, основанные на классах, указывают ссылки, классы называют ссылочными типами.  
  
## <a name="class-inheritance"></a>Наследование классов  

Классы полностью поддерживают *наследование*, фундаментальный механизм объектно ориентированного программирования. Создаваемый класс может наследовать от любого другого класса, который не определен как [запечатанный](../../language-reference/keywords/sealed.md), а другие классы могут наследовать от этого класса и переопределять его виртуальные методы. Кроме того, можно реализовать один или несколько интерфейсов.

При наследовании создается *производный* класс, то есть класс объявляется с помощью *базового класса*, от которого он наследует данные и поведение. Базовый класс задается добавлением после имени производного класса двоеточия и имени базового класса, как показано далее:  

 ```csharp
 public class Manager : Employee
 {
     // Employee fields, properties, methods and events are inherited
     // New Manager fields, properties, methods and events go here...
 }
 ```

Когда класс объявляет базовый класс, он наследует все члены базового класса, за исключением конструкторов. Дополнительные сведения см. в разделе [Наследование](inheritance.md).
  
В отличие от C++, класс в C# может только напрямую наследовать от одного базового класса. Тем не менее, поскольку базовый класс может сам наследовать от другого класса, класс может косвенно наследовать от нескольких базовых классов. Кроме того, класс может напрямую реализовать несколько интерфейсов. Дополнительные сведения см. в разделе [Интерфейсы](../interfaces/index.md).  
  
Класс может быть объявлен [абстрактным](../../language-reference/keywords/abstract.md). Абстрактный класс содержит абстрактные методы, которые имеют определение сигнатуры, но не имеют реализации. Нельзя создавать экземпляры абстрактных классов. Они могут использоваться только через производные классы, реализующие абстрактные методы. И наоборот, [запечатанный](../../language-reference/keywords/sealed.md) класс не позволяет другим классам быть от него производными. Дополнительные сведения см. в статье [Абстрактные и запечатанные классы и члены классов](abstract-and-sealed-classes-and-class-members.md).  
  
Определения классов можно разделить между различными исходными файлами. Дополнительные сведения см. в разделе [Разделяемые классы и методы](partial-classes-and-methods.md).  
  
## <a name="example"></a>Пример

В следующем примере определяется открытый класс, содержащий [автоматически реализуемое свойство](auto-implemented-properties.md), метод и специальный метод, который называется конструктором. См. дополнительные сведения о [свойствах](properties.md), [методах](methods.md) и [конструкторах](constructors.md). Затем создаются экземпляры этого класса с помощью ключевого слова `new`.  
  
[!code-csharp[Class Example](~/samples/snippets/csharp/programming-guide/classes-and-structs/class-example.cs)]
  
## <a name="c-language-specification"></a>Спецификация языка C#

[!INCLUDE[CSharplangspec](~/includes/csharplangspec-md.md)]  
  
## <a name="see-also"></a>См. также

- [Руководство по программированию на C#](../index.md)
- [Объектно-ориентированное программирование](../../tutorials/intro-to-csharp/object-oriented-programming.md)
- [Полиморфизм](polymorphism.md)
- [Имена идентификаторов](../inside-a-program/identifier-names.md)
- [Члены](members.md)
- [Методы](methods.md)
- [Конструкторы](constructors.md)
- [Методы завершения](destructors.md)
- [Объекты](objects.md)
